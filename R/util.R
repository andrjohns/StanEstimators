write_data <- function(Npars, finite_diff, lower_bounds, upper_bounds, bounds_types, data_filepath) {
  no_bounds <- all(lower_bounds == -Inf) && all(upper_bounds == Inf)
  dat_string <- paste(
    '{',
    '"Npars" : ', Npars, ',',
    '"finite_diff" : ', finite_diff, ',',
    '"no_bounds" : ', as.integer(no_bounds), ',',
    '"lower_bounds" : [', paste0(lower_bounds, collapse = ','), '],',
    '"upper_bounds" : [', paste0(upper_bounds, collapse = ','), '],',
    '"bounds_types" : [', paste0(bounds_types, collapse = ','), ']',
    '}'
  )
  writeLines(dat_string, con = data_filepath)
  dat_string
}

inits_to_json <- function(inits) {
  paste0('{ "pars" : [', paste0(inits, collapse = ','), ']}')
}

write_inits <- function(inits, init_filepath) {
  lapply(seq_len(length(inits)), function(i) {
    dat_string <- inits_to_json(inits[[i]])
    writeLines(dat_string, con = init_filepath[[i]])
    dat_string
  })
}

prepare_and_write_json <- function(what, input_list) {
  if (what == "data") {
    args <- c("Npars", "finite_diff", "lower_bounds", "upper_bounds", "bounds_types", "data_filepath")
    write_fun <- write_data
  } else if (what == "inits") {
    args <- c("inits", "init_filepath")
    write_fun <- write_inits
  } else {
    args <- c()
    write_fun <- function() { stop("Invalid write method!", call. = FALSE) }
  }
  do.call(write_fun, input_list[args])
}

with_env <- function(f, e=parent.frame()) {
  stopifnot(is.function(f))
  environment(f) <- e
  f
}

validate_function <- function(fn, inits, extra_args_list, grad = FALSE) {
  fn_type <- ifelse(isTRUE(grad), "Gradient", "Log-Likelihood")
  test_fn <- try(invisible(fn(inits)), silent = TRUE)
  correct_length <- ifelse(isTRUE(grad), length(inits), 1)

  if (inherits(test_fn, "try-error")) {
    stop(fn_type, " function evaluated at initial values resulted in error: \n ",
         test_fn, call. = FALSE)
  } else if (any(!is.finite(test_fn))) {
    stop(fn_type, " function evaluated at initial values is not finite!",
         call. = FALSE)
  } else if (length(test_fn) != correct_length) {
    stop(fn_type, " function should have return of length ", correct_length,
          ", but return was length ", length(test_fn), "instead!", call. = FALSE)
  } else {
    invisible(NULL)
  }
}

prepare_inputs <- function(fn, par_inits, n_pars, extra_args_list, grad_fun, lower, upper,
                            globals, packages, eval_standalone, output_dir, output_basename, num_chains = 1) {
  user_inits <- TRUE
  if (is.null(par_inits)) {
    if (is.null(n_pars)) {
      stop("Must provide either par_inits or n_pars!", call. = FALSE)
    }
    if ((n_pars > 1) && (length(lower) == 1)) {
      lower <- rep(lower, n_pars)
    }
    if ((n_pars > 1) && (length(upper) == 1)) {
      upper <- rep(upper, n_pars)
    }
    # Generate and constrain random inits just for function validation
    # Actual inits will be generated by Stan
    par_inits <- lub_constrain(stats::runif(n_pars, -2, 2), lower, upper)
    user_inits <- FALSE
  }

  inits <- NULL
  if (is.list(par_inits)) {
    if (length(par_inits) != num_chains) {
      stop("If par_inits is a list, it must have length equal to num_chains",
           call. = FALSE)
    }
    inits <- par_inits
  } else if (is.numeric(par_inits)) {
    inits <- lapply(seq_len(num_chains), function(i) { par_inits })
  } else if (is.function(par_inits)) {
    inits <- lapply(seq_len(num_chains), function(i) { par_inits(i) })
  } else {
    stop("par_inits must be NULL, a numeric vector, a list of numeric vectors, or a function",
         call. = FALSE)
  }

  fn1 <- function(v) { do.call(fn, c(list(v), extra_args_list)) }
  for (chain in seq_len(num_chains)) {
    validate_function(fn1, inits[[chain]], extra_args_list, grad = FALSE)
  }
  fun_globals <- NULL
  fun_packages <- NULL
  if (isTRUE(eval_standalone)) {
    callr_future_installed <- sapply(c("callr", "future"), function(pkg) {
      requireNamespace(pkg, quietly = TRUE)
    })

    if (!all(callr_future_installed)) {
      stop("To use `eval_standalone = TRUE` or `parallel_chains > 1`, ",
          "you must install the `callr` and `future` packages.",
          call. = FALSE)
    }
    gp <- future::getGlobalsAndPackages(fn, globals = globals)
    fun_globals <- gp$globals
    fun_packages <- c(gp$packages, packages)
  }
  if (!is.null(grad_fun)) {
    gr1 <- function(v) { do.call(grad_fun, c(list(v), extra_args_list)) }
    for (chain in seq_len(num_chains)) {
      validate_function(gr1, inits[[chain]], extra_args_list, grad = TRUE)
    }
    if (isTRUE(eval_standalone)) {
      gr_gp <- future::getGlobalsAndPackages(grad_fun, globals = globals)
      fun_globals <- c(fun_globals, gr_gp$globals)
      fun_packages <- c(fun_packages, gr_gp$packages)
    }
  } else {
    gr1 <- fn1
  }

  if ((length(inits[[1]]) > 1) && (length(lower) == 1)) {
    lower <- rep(lower, length(inits[[1]]))
  }
  if ((length(inits[[1]]) > 1) && (length(upper) == 1)) {
    upper <- rep(upper, length(inits[[1]]))
  }
  bounds_types <- sapply(seq_len(length(inits[[1]])), function(i) {
    if (lower[i] != -Inf && upper[i] != Inf) {
      3
    } else if (lower[i] != -Inf) {
      1
    } else if (upper[i] != Inf) {
      2
    } else {
      4
    }
  })
  if (is.null(output_dir)) {
    output_dir <- tempdir()
  }
  if (is.null(output_basename)) {
    output_basename <- tempfile(tmpdir = output_dir)
  } else {
    output_basename <- file.path(output_dir, output_basename)
  }

  init_filepath <- NULL
  if (user_inits) {
    init_filepath <- sapply(seq_len(num_chains), function(i) {
      tempfile(fileext = ".json", tmpdir = output_dir)
    })
  }

  structured <- list(
    ll_function = fn1,
    grad_function = gr1,
    globals = fun_globals,
    packages = fun_packages,
    eval_standalone = eval_standalone,
    inits = inits,
    finite_diff = as.integer(is.null(grad_fun)),
    Npars = length(inits[[1]]),
    lower_bounds = lower,
    upper_bounds = upper,
    bounds_types = bounds_types,
    data_filepath = tempfile(fileext = ".json", tmpdir = output_dir),
    init_filepath = init_filepath,
    output_filepath = paste0(output_basename, ".csv"),
    output_basename = output_basename
  )
  init_json_string <- NULL
  if (user_inits) {
    init_json_string <- prepare_and_write_json("inits", structured)
  }
  data_json_string <- prepare_and_write_json("data", structured)
  structured$data_string <- data_json_string
  structured$init_string <- init_json_string
  structured
}

cmdstan_syntax_tree <- list(
  "sample" = list(
    "num_samples",
    "num_warmup",
    "save_warmup",
    "thin",
    "adapt" = list(
      "engaged",
      "gamma",
      "delta",
      "kappa",
      "t0",
      "init_buffer",
      "term_buffer",
      "window"
    ),
    "algorithm" = list(
      "hmc" = list(
        "engine" = list(
          "static" = list(
            "int_time"
          ),
          "nuts" = list(
            "max_depth"
          )
        ),
        "metric",
        "metric_file",
        "stepsize",
        "stepsize_jitter"
      ),
      "fixed_param"
    ),
    "num_chains"
  ),
  "optimize" = list(
    "algorithm" = list(
      "bfgs" = list(
        "init_alpha",
        "tol_obj",
        "tol_rel_obj",
        "tol_grad",
        "tol_rel_grad",
        "tol_param"
      ),
      "lbfgs" = list(
        "init_alpha",
        "tol_obj",
        "tol_rel_obj",
        "tol_grad",
        "tol_rel_grad",
        "tol_param",
        "history_size"
      ),
      "newton"
    ),
    "jacobian",
    "iter",
    "save_iterations"
  ),
  "variational" = list(
    "algorithm",
    "iter",
    "grad_samples",
    "elbo_samples",
    "eta",
    "adapt" = list(
      "engaged",
      "iter"
    ),
    "tol_rel_obj",
    "eval_elbo",
    "output_samples"
  ),
  "pathfinder" = list(
    "init_alpha",
    "tol_obj",
    "tol_rel_obj",
    "tol_grad",
    "tol_rel_grad",
    "tol_param",
    "history_size",
    "num_psis_draws",
    "num_paths",
    "save_single_paths",
    "max_lbfgs_iters",
    "num_draws",
    "num_elbo_draws"
  ),
  "laplace" = list(
    "mode",
    "jacobian",
    "draws"
  ),
  "data" = list(
    "file"
  ),
  "init",
  "random" = list(
    "seed"
  ),
  "output" = list(
    "file",
    "diagnostic_file",
    "refresh",
    "sig_figs",
    "profile_file"
  ),
  "num_threads"
)

# Need to refactor this, what a mess
parse_method_args <- function(method, method_args) {
  method_tree <- cmdstan_syntax_tree[[method]]
  return_args <- c("")
  if (!is.null(method_tree$algorithm)) {
    algorithm <- method_args$algorithm
    algo_tree <- method_tree$algorithm[[method_args$algorithm]]
    engine_string <- ""

    if (!is.null(algo_tree$engine)) {
      engine_args <- sapply(algo_tree$engine[[method_args$algorithm_args$engine]], function(eng_arg) {
        ifelse(!is.null(method_args$algorithm_args$engine_args[[eng_arg]]),
               paste0(eng_arg, "=", method_args$algorithm_args$engine_args[[eng_arg]]),
               "")
      })
      algo_tree <- algo_tree[-grep("engine", names(algo_tree))]
      engine_string <- c(paste0("engine=", method_args$algorithm_args$engine), engine_args)
    }

    algorithm_args <- sapply(algo_tree, function(arg) {
        ifelse(!is.null(method_args$algorithm_args[[arg]]),
              paste0(arg, "=", method_args$algorithm_args[[arg]]),
              "")
    })
    return_args <- c(return_args, paste0("algorithm=", algorithm), engine_string, algorithm_args[algorithm_args != ""])
    method_tree <- method_tree[-grep("algorithm", names(method_tree))]
  }
  if (!is.null(method_tree$adapt)) {
    adapt_args <- sapply(method_tree$adapt, function(arg) {
      ifelse(!is.null(method_args$adapt[[arg]]),
             paste0(arg, "=", method_args$adapt[[arg]]),
             "")
    })
    adapt_args <- adapt_args[adapt_args != ""]
    if (length(adapt_args) > 0)
    return_args <- c(return_args, "adapt", adapt_args)
    method_tree <- method_tree[-grep("adapt", names(method_tree))]
  }

  other_args <- sapply(method_tree, function(arg) {
    ifelse(!is.null(method_args[[arg]]),
          paste0(arg, "=", method_args[[arg]]),
          "")
  })
  c(return_args, unlist(other_args[other_args != ""]))
}

parse_output_args <- function(output_args) {
  valid_args <- cmdstan_syntax_tree[["output"]]
  parsed_args <- sapply(valid_args, function(arg) {
    ifelse(!is.null(output_args[[arg]]),
      paste0(arg, "=", output_args[[arg]]),
      "")
  })
  c("output", parsed_args[parsed_args != ""])
}

build_stan_call <- function(method, method_args, data_file, init, seed, output_args, id = NULL) {
  if (method == "diagnose") {
    method_string <- ""
  } else {
    method_string <- parse_method_args(method, method_args)
  }
  data_string <- c("data", paste0("file=", data_file))
  init_string <- paste0("init=", init)
  if (!is.null(init)) {
    init_string <- paste0("init=", init)
  } else {
    init_string <- ""
  }
  if (!is.null(seed)) {
    random_string <- c("random", paste0("seed=", seed))
  } else {
    random_string <- ""
  }
  if (!is.null(id)) {
    id_string <- paste0("id=", id)
  } else {
    id_string <- ""
  }
  output_string <- parse_output_args(output_args)
  args <- unlist(c(method, method_string, id_string, data_string, init_string, random_string, output_string))
  args[args != ""]
}

call_stan <- function(args_list, input_list, quiet) {
  if (!isTRUE(input_list$eval_standalone)) {
    call_stan_impl(args_list, input_list)
    return(invisible(NULL))
  }
  r_bg_args <- list(
    args_list,
    input_list
  )
  proc <- callr::r_bg(call_stan_impl, args = r_bg_args,
                      supervise = TRUE,
                      package = "StanEstimators")
  while (proc$is_alive()) {
    proc$wait(0.1)
    proc$poll_io(0)
    if (!quiet) {
      lines <- proc$read_output_lines()
      if (length(lines) > 0) {
        for (line in lines) {
          if (line != "") {
            cat(line, "\n")
          }
        }
      }
    }
  }
  errs <- proc$read_error_lines()
  errs <- errs[errs != ""]
  if (length(errs) > 0) {
    message(paste0(errs, collapse = " "))
  }
  invisible(NULL)
}

format_bool <- function(input) {
  if (!is.null(input)) {
    input <- as.integer(input)
  }
  input
}

to_draws_format <- function(draws, draws_format) {
  valid_formats <- c("draws_array", "draws_df", "draws_list",
                      "draws_matrix", "draws_rvars")
  if (!(draws_format %in% valid_formats)) {
    stop("Invalid draws_format! Valid formats are: ",
          paste0(valid_formats, collapse = ", "),
         call. = FALSE)
  }
  get(paste0("as_", draws_format), loadNamespace("posterior"))(draws)
}

match_draws_format <- function(reference_draws, draws) {
  reference_format <- class(reference_draws)[1]
  to_draws_format(draws, reference_format)
}

check_hmc_diagnostics <- function(draws_df, max_treedepth) {
  num_draws <- nrow(draws_df)
  n_divergent <- sum(draws_df$divergent__)
  perc_divergent <- round(100 * n_divergent / num_draws, 2)

  if (n_divergent > 0) {
    message(
      n_divergent, " of ", num_draws, " (", perc_divergent, "%)",
      " iterations ended with a divergence.\n",
      "These divergent transitions indicate that HMC is not fully able to ",
      "explore the posterior distribution.\n",
      "Try increasing adapt_delta closer to 1.\n",
      "If this doesn't remove all divergences, try to reparameterize the model.")
  }

  max_treedepths <- sum(draws_df$treedepth__ > max_treedepth)
  perc_treedepth <- round(100 * max_treedepths / num_draws, 2)

  if (max_treedepths > 0) {
    message(
      max_treedepths, " of ", num_draws, " (", perc_treedepth, "%)",
      " transitions hit the maximum treedepth limit of ", max_treedepth,
      ", or 2^", max_treedepth, " leapfrog steps.\n",
      "Trajectories that are prematurely terminated due to this limit will ",
      "result in slow exploration.\n",
      "For optimal performance, increase this limit."
      )
  }

  ebfmi_thresholds_by_chain <- sapply(split(draws_df$energy__, f = draws_df$.chain), function(x) {
    ((sum(diff(x)^2) / length(x)) / stats::var(x)) < 0.3
  })

  num_below_threshold <- sum(ebfmi_thresholds_by_chain)

  if (num_below_threshold > 0) {
    message(
      num_below_threshold, " of ", length(ebfmi_thresholds_by_chain),
      " chains had an E-BFMI below the nominal threshold of 0.3 which ",
      "suggests that HMC may have trouble exploring the target distribution.\n",
      "If possible, try to reparameterize the model."
    )
  }
  invisible(NULL)
}
